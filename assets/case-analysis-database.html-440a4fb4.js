import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as d,c as a,e as i}from"./app-b32ebd48.js";const t={},r=i('<div class="hint-container tip"><p class="hint-container-title">前言</p><p><code>系统架构设计师</code> 考试中下午案例分析题知识点汇总。本篇是数据库专题部分。</p></div><h2 id="概念" tabindex="-1"><a class="header-anchor" href="#概念" aria-hidden="true">#</a> 概念</h2><h3 id="超类实体" tabindex="-1"><a class="header-anchor" href="#超类实体" aria-hidden="true">#</a> 超类实体</h3><ul><li>某个实体类型中所有实体同时也是另一个实体类型中的实体，此时称前一实体为子类实体，后一实体为超类实体。或根据官方教程由一种已知类型定义新的类型。通常把已知类型称为超类, 新定义的类型称为子类。</li></ul><h3 id="派生属性" tabindex="-1"><a class="header-anchor" href="#派生属性" aria-hidden="true">#</a> 派生属性</h3><ul><li>实体的某个属性可以从其他属性或其他数据推导出来，那么这个属性就是派生属性。</li></ul><h3 id="索引" tabindex="-1"><a class="header-anchor" href="#索引" aria-hidden="true">#</a> 索引</h3><ul><li>索引是提高数据库查询效率的机制，但不能进行数据更新。</li><li>数据库索引：提升查询效率，降低添加、修改、删除效率。采用 B 树，B+树等。</li></ul><h3 id="视图" tabindex="-1"><a class="header-anchor" href="#视图" aria-hidden="true">#</a> 视图</h3><ul><li>视图具有一定的安全机制，但也不能更新数据。</li></ul><h3 id="触发器" tabindex="-1"><a class="header-anchor" href="#触发器" aria-hidden="true">#</a> 触发器</h3><ul><li>触发器可以作为更新机制，但无法完全保证数据库安全性。</li></ul><h3 id="存储过程" tabindex="-1"><a class="header-anchor" href="#存储过程" aria-hidden="true">#</a> 存储过程</h3><ul><li>存储过程可以定义一段代码来提供给用户程序调用，通过代码调用来实现更新，避免了向第三方提供系统表结构的过程，从而更好地保证了数据库的安全性。</li></ul><h2 id="数据库设计过程" tabindex="-1"><a class="header-anchor" href="#数据库设计过程" aria-hidden="true">#</a> 数据库设计过程</h2><ul><li>基于数据库系统生命周期的数据库设计可分为如下 5 个阶段：<code>规划、需求分析、概念设计、逻辑设计和物理设计</code>。</li></ul><h3 id="设计阶段" tabindex="-1"><a class="header-anchor" href="#设计阶段" aria-hidden="true">#</a> 设计阶段</h3><table><thead><tr><th>阶段</th><th>主要任务</th></tr></thead><tbody><tr><td>用户需求分析</td><td>分析用户活动、收集数据确定系统边界。</td></tr><tr><td>概念结构设计</td><td>将应用对象抽象成不依赖于 DBMS 的数据模型，即概念模型。描述概念模型的较理想的工具是 E-R 图。</td></tr><tr><td>逻辑结构设计</td><td>将抽象的概念模型转化为与选用的 DBMS 产品所支持的数据模型相符合的逻辑模型，即关系模式。</td></tr><tr><td>物理结构设计</td><td>是逻辑模型在计算机中的具体实现方案。</td></tr><tr><td>数据库实施阶段</td><td>根据前两个阶段的结果建立数据库，编制与调试应用程序，组织数据入库，并进行试运行。</td></tr><tr><td>数据库运行和维护阶段</td><td>数据库应用系统经过试运行即可投入运行，但该阶段需要不断地对系统进行评价、调整与修改。</td></tr></tbody></table><h3 id="规划" tabindex="-1"><a class="header-anchor" href="#规划" aria-hidden="true">#</a> 规划</h3><p>规划阶段的主要任务是进行建立数据库的必要性及可行性分析，确定数据库系统在企业和信息系统中的地位，以及各个数据库之间的联系。</p><h3 id="需求分析" tabindex="-1"><a class="header-anchor" href="#需求分析" aria-hidden="true">#</a> 需求分析</h3><p>调查组织机构情况、调查各部门的业务活动情况、协助用户明确对新系统的各种要求、确定新系统的边界，以此获得用户对系统的如下要求。<br> ① <code>信息要求</code>: 保存的信息、完整性要求等。<br> ② <code>处理要求</code>: 操作功能、处理的频度、相应时间等。<br> ③ <code>系统要求</code>: 安全性要求、使用方式要求、可扩充性要求。</p><h3 id="概念结构设计" tabindex="-1"><a class="header-anchor" href="#概念结构设计" aria-hidden="true">#</a> 概念结构设计</h3><p>对现实事物抽象认识的 3 种方法:</p><ol><li><code>分类(Classification)</code>: 对现实世界的事物，按照其具有的共同特征和行为，定义一种类型。在某一类型中，个体是类型的一个成员或实例，即 “is member of”。</li><li><code>聚集(Aggregation)</code>: 定义某一类型所具有的属性。如学生类型具有学号、姓名、性别、班级等共同属性，每一个学生都是这一类型中的个体, 通过在这些属性上的不同取值来区分。各个属性是所属类型的一个成份，即 “is part of”。</li><li><code>概括(Generalization)</code>: 由一种已知类型定义新的类型。通常把已知类型称为超类(Superclass), 新定义的类型称为子类(Subclass), 即 “is subset&quot;</li></ol><p>概念设计步骤</p><ol><li>需求分析</li><li>确定局部视图范围</li><li>识别实体及其标识</li><li>确定实体之间的联系</li><li>分配实体及联系的属性</li><li>全局 E-R 模式设计</li></ol><p>冲突的类型</p><ol><li><code>属性冲突</code>: 包括属性域和属性取值的冲突</li><li><code>结构冲突</code>: 包括同一个对象在不同应用中的抽象以及同一实体在不同的局部 E-R 图中所包含的属性个数和属性排列次序不完全相同</li><li><code>命名冲突</code>: 包括同名异议和异名同议</li></ol><h3 id="逻辑结构设计" tabindex="-1"><a class="header-anchor" href="#逻辑结构设计" aria-hidden="true">#</a> 逻辑结构设计</h3><ul><li>将抽象的概念模型转化为与选用的 DBMS 产品所支持的数据模型相符合的逻辑模型，即关系模式。</li><li>主要工作步骤包括确定数据模型、将 E-R 图转换成为指定的数据模型、确定完整性约束和确定用户视图。</li></ul><h3 id="物理设计" tabindex="-1"><a class="header-anchor" href="#物理设计" aria-hidden="true">#</a> 物理设计</h3><p>物理设计的主要工作步骤包括确定数据分布、存储结构和访问方式。</p><h3 id="数据库实施" tabindex="-1"><a class="header-anchor" href="#数据库实施" aria-hidden="true">#</a> 数据库实施</h3><p>数据库实施。在计算机上建立起实际的数据库结构，数据加载(或称装入)，进行试运行和评价的过程，叫作数据库的实施(或称实现)</p><h3 id="数据库运行维护" tabindex="-1"><a class="header-anchor" href="#数据库运行维护" aria-hidden="true">#</a> 数据库运行维护</h3><p>数据库运行维护。数据库一旦投入运行，就标志着数据库维护工作的开始。数据库维护工作的主要内容包括对数据库性能的监测和改善、故障恢复、数据库的重组和重构。</p><h2 id="数据库访问接口" tabindex="-1"><a class="header-anchor" href="#数据库访问接口" aria-hidden="true">#</a> 数据库访问接口</h2><p>常见的数据库访问接口有专用调用、开放数据库互连（ODBC）和 Java 数据库连接（JDBC）等。</p><p>ODBC 其缺点要体现在以下三个方面</p><ul><li>ODBC 只支持关系型数据，像电子邮件之类的非关系型数据是不支持的。</li><li>由于 ODBC 最初的设计理念就是能够访问所有类型数据库，这种普遍适用也造成了 ODBC 对每种数据库的支持都不是特别理想。</li><li>使用 ODBC 需要进行一些系统的配置工作。当然，这个操作也是可以用程序来完成的。</li></ul><h2 id="事物的特性-acid" tabindex="-1"><a class="header-anchor" href="#事物的特性-acid" aria-hidden="true">#</a> 事物的特性 ACID</h2><ul><li><code>原子性（Atomicity）</code>。事务是数据库的逻辑工作单位，事务的原子性保证事务包含的一组更新操作是原子不可分的，也就是说，这些操作是一个整体，不能部分地完成。</li><li><code>一致性（Consistency）</code>。一致性是指使数据库从一个一致性状态变到另一个一致性状态。</li><li><code>隔离性（Isolation）</code>。隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</li><li><code>持久性（Durability）</code>。持久性也称为永久性，是指事务一旦提交，改变就是永久性的，无论发生何种故障，都不应该对其有任何影响。</li></ul><h2 id="数据不一致问题" tabindex="-1"><a class="header-anchor" href="#数据不一致问题" aria-hidden="true">#</a> 数据不一致问题</h2><ul><li><code>丢失修改</code>。事务 A 与事务 B 从数据库中读入同一数据并修改，事务 B 的提交结果破坏了事务 A 提交的结果，导致事务 A 的修改被丢失。</li><li><code>读 “脏数据”</code>。事务 A 修改某一数据，并将其写回磁盘，事务 B 读取同一数据后，事务 A 由于某种原因被撤销，这时事务 A 已修改过的数据恢复原值，事务 B 读到的数据就与数据库中的数据不一致，是不正确的数据，称为“脏数据”。</li><li><code>不可重复读</code>。不可重复读是指事务 A 读取数据后，事务 B 执行了更新操作，事务 A 使用的仍是更新前的值，造成了数据不一致性。</li></ul><h2 id="范式" tabindex="-1"><a class="header-anchor" href="#范式" aria-hidden="true">#</a> 范式</h2><ul><li>第一范式（1NF）。在关系模式中，当且仅当所有属性只包含原子值，即每个分量都是不可再分的数据项，则称满足 1NF。</li><li>第二范式（2NF）。当且仅当关系模式及满足 1NF，且每个非键属性（即不属于任何候选键的属性，也称为非主属性）完全依赖于候选键时，则称满足 2NF。</li><li>第三范式（3NF）。当且仅当关系模式 R 满足 1NF，且 R 中没有非键属性传递依赖于候选键时，则称满足 3NF。</li><li>BCNF。如果关系模式及满足 1NF，且及中没有属性传递依赖于候选键时，则称满足 BCNF。</li><li>第四范式（4NF）。第四范式是 BCNF 的推广，是针对有多值依赖的关系模型所定义的规范化形式。把一个表中多个多值依赖拆分开来。</li></ul><h2 id="反规范化设计" tabindex="-1"><a class="header-anchor" href="#反规范化设计" aria-hidden="true">#</a> 反规范化设计</h2><div class="hint-container tip"><p class="hint-container-title">提示</p><p>规范化设计后，数据库设计者希望牺牲部分规范化来提高性能，这种从规范化设计的回退方法称为反规范化技术。<br> 逆规范化方法优点：提高统计、查询效率。<br> 逆规范化方法缺点：增加了数据冗余，浪费存储空间，增、删、改操作的效率降低，可能导致数据不一致，可能产生添加、修改、删除异常</p></div><h3 id="优点" tabindex="-1"><a class="header-anchor" href="#优点" aria-hidden="true">#</a> 优点</h3><ul><li>避免进行表之间的连接操作，可以提高数据操作的性能。</li><li>连接操作少，检索快、统计快;需要查的表减少，检索容易，并易出错。</li></ul><h3 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点" aria-hidden="true">#</a> 缺点</h3><ul><li>数据的重复存储，浪费了磁盘空间</li><li>会产生数据的不一致性问题(触发器数据同步、应用程序同步)</li><li>更新和插入代码更加难写</li><li>插入、更新、删除操作开销更大</li></ul><h3 id="反规范化设计类型" tabindex="-1"><a class="header-anchor" href="#反规范化设计类型" aria-hidden="true">#</a> 反规范化设计类型</h3><table><thead><tr><th>类型</th><th>作用 / 描述</th></tr></thead><tbody><tr><td>增加冗余列</td><td>增加冗余列是指在多个表中具有相同的列，它常用来在查询时避免连接操作。</td></tr><tr><td>增加派生列</td><td>增加派生列指增加的列可以通过表中其他数据计算生成它的作用是在查询时减少计算量，从而加快查询速度</td></tr><tr><td>重新组表</td><td>重新组表指如果许多用户需要查看两个表连接出来的结果数据，则把这两个表重新组成一个表来减少连接而提高性能</td></tr><tr><td>水平分割表</td><td>按记录进行分割，把数据放到多个独立的表中，主要用于表数据规模很大、表中数据相对独立或数据需要存放到多个介质上时使用。</td></tr><tr><td>垂直分割表</td><td>对表进行分割，将主键与部分列放到一个表中，主键与其它列放到另一个表中，在查询时减少 1/0 次数。</td></tr></tbody></table><h3 id="数据一致性" tabindex="-1"><a class="header-anchor" href="#数据一致性" aria-hidden="true">#</a> 数据一致性</h3><p>反规范化设计保证数据的一致性方法:</p><ul><li>触发器</li><li>事务机制保证</li><li>应用保证</li><li>批处理脚本</li></ul><h2 id="数据库的完整性" tabindex="-1"><a class="header-anchor" href="#数据库的完整性" aria-hidden="true">#</a> 数据库的完整性</h2><ul><li><code>完整性约束条件</code>: 完整性检查是指对数据库中的数据设置约束条件，确保数据符合预定义的规则。 完整性检查可以帮助我们防止数据错误。 完整性控制机制包括定义功能和检查功能。定义功能用于定义完整性约束条件。检查功能用于检查用户操作是否违反了完整性约束条件。完整性检查可以分为静态约束和动态约束。静态约束对数据库中数据本身的限制，例如数据类型、取值范围等。动态约束对数据库中数据变化的限制。</li><li><code>实体完整性</code>: 实体完整性要求主键中的任一属性不能为空，所谓空值是“不知道”或“无意义”的值。</li><li><code>参照完整性</code>: 若基本关系及中含有与另一基本关系 S 的主键 PK 相对应的属性组 FK（FK 称为 R 的外键），则参照完整性要求，对及中的每个元组在 FK 上的值必须是 S 中某个元组的 PK 值，或者为空值。</li><li><code>用户定义的完整性</code>: 用户定义的完整性就是针对某一具体数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求。</li><li><code>触发器</code>: 所谓触发器，其抽象的含义即是一个事件的发生必然触发（或导致）另外一些事件的发生，其中前面的事件称为触发事件，后面的事件称为结果事件。触发事件一般即为完整性约束条件的否定，而结果事件即为一组操作用以消除触发事件所引起的不良影响。 触发器除了有完整性保护功能外，还有安全性保护功能。</li></ul><h2 id="数据库性能优化" tabindex="-1"><a class="header-anchor" href="#数据库性能优化" aria-hidden="true">#</a> 数据库性能优化</h2><h3 id="主从复制" tabindex="-1"><a class="header-anchor" href="#主从复制" aria-hidden="true">#</a> 主从复制</h3><p>主从复制，是用来建立一个和主数据库完全一样的数据库环境，称为从数据库。这样做的好处是:</p><ol><li>做数据的热备。作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避免数据丢失。</li><li>架构的扩展。、业务量越来越大，I/O 访问频率过高，单机无法满足此时做多库的存储，降低磁盘 I/O 访问的频率，提高单个机器的 I/O 性能。</li><li>读写分离。使数据库能支持更大的并发。</li></ol><h3 id="读写分离" tabindex="-1"><a class="header-anchor" href="#读写分离" aria-hidden="true">#</a> 读写分离</h3><p>读写分离: 设置不同的主/从数据库分别负责不同的操作。让主数据库负责数据的写操件，从数据库负责数据的读操作。通过角色分担的策略，分别提升读写性能，有效减少数据并发操作的延迟。</p><h3 id="分库" tabindex="-1"><a class="header-anchor" href="#分库" aria-hidden="true">#</a> 分库</h3><p>分库，将原本存放在一个实例上众多分类的数据(表)，分开存放到不同的实例上。有利于差异化管理。</p><h3 id="分表" tabindex="-1"><a class="header-anchor" href="#分表" aria-hidden="true">#</a> 分表</h3><p>分表也叫分片，解决并发能力、1/0 性能提升、将一张大表分成若干小表，业务同时访问多个表。分表是重在单个实例内部，一张表拆分成多个表。</p><h2 id="分布式数据库的优点" tabindex="-1"><a class="header-anchor" href="#分布式数据库的优点" aria-hidden="true">#</a> 分布式数据库的优点</h2><p>分布式数据库的物理层面分布、逻辑层面统一的特色，让它具有一些集中式数据库所不可及的优势。</p><ul><li>分布式数据库可以解决企业部门分散而数据需要相互联系的问题。</li><li>如果企业需要增加新的相对自主的部门来扩充机构，则分布式数据库系统可以在对当前机构影响最小的情况下进行扩充。</li><li>分布式数据库可以满足均衡负载的需要。</li><li>当企业己存在几个数据库系统，而且实现全局应用的必要性增加时，就可以由这些数据库自下而上构成分布式数据库系统。</li><li>相等规模的分布式数据库系统在出现故障的概率上不会比集中式数据库系统低 。</li></ul><h2 id="nosql" tabindex="-1"><a class="header-anchor" href="#nosql" aria-hidden="true">#</a> NoSQL</h2><h3 id="nosql-优势" tabindex="-1"><a class="header-anchor" href="#nosql-优势" aria-hidden="true">#</a> NoSQL 优势</h3><p>（1）<code>可扩展性——NoSQL</code>: 数据库可以轻松地扩展到处理海量数据，而无需昂贵的硬件或复杂的配置。<br> （2）<code>高并发性——NoSQL</code>: 数据库可以处理大量并发请求，使其非常适合处理实时数据和高流量应用程序。<br> （3）<code>灵活性—— NoSQL</code>: 数据库提供灵活的数据模型，可以轻松适应不断变化的数据需求，而无需更改架构。<br> （4）<code>高可用性——NoSQL</code>: 数据库通常具有高可用性，并提供冗余和故障转移功能，以确保数据始终可用。</p><h3 id="nosql-解决的问题" tabindex="-1"><a class="header-anchor" href="#nosql-解决的问题" aria-hidden="true">#</a> NoSQL 解决的问题</h3><p>（1）<code>大数据处理</code>: 关系数据库在处理海量数据时性能较差，而 NoSQL 数据库可以轻松扩展以处理 TB 级甚至 PB 级的数据。<br> （2）<code>并发性</code>: 关系数据库在高并发环境下容易出现瓶颈，而 NoSQL 数据库可以同时处理大量并发请求。<br> （3）<code>数据灵活性</code>: 关系数据库的固定模式限制了数据存储和检索的灵活性，而 NoSQL 数据库提供了更灵活的数据模型。<br> （4）<code>成本</code>: NoSQL 数据库通常比关系数据库更具成本效益，因为它们可以运行在廉价的硬件上，并且不需要昂贵的许可证。</p><h3 id="nosql-带来的问题" tabindex="-1"><a class="header-anchor" href="#nosql-带来的问题" aria-hidden="true">#</a> NoSQL 带来的问题</h3><p>（1）<code>数据一致性</code>: NoSQL 数据库通常提供最终一致性，而不是关系数据库提供的强一致性，这可能会导致数据不一致。<br> （2）<code>事务处理</code>: NoSQL 数据库通常不提供事务支持，这使得跨多个操作维护数据完整性变得困难。<br> （3）<code>查询功能</code>: NoSQL 数据库的查询功能可能不如关系数据库强大，这可能会限制复杂查询和数据分析。<br> （4）<code>数据建模</code>: NoSQL 数据库的非关系数据模型需要不同的建模技术，这可能需要学习曲线。</p><h2 id="分布式缓存技术" tabindex="-1"><a class="header-anchor" href="#分布式缓存技术" aria-hidden="true">#</a> 分布式缓存技术</h2><h3 id="redis-作用" tabindex="-1"><a class="header-anchor" href="#redis-作用" aria-hidden="true">#</a> Redis 作用</h3><p>redis 用作缓存组件时，其基于肉存的读写特性，比基于磁盘读写的数据库性能要高很多，适合缓存高频热点的数据，来提高读性能这样可以降低对数据库服务器的查询请求，提高系统性能。</p><h3 id="redis-读写数据基本步骤" tabindex="-1"><a class="header-anchor" href="#redis-读写数据基本步骤" aria-hidden="true">#</a> Redis 读写数据基本步骤</h3><p>读数据:</p><ol><li>根据 key 值查询缓存</li><li>读取成功则直接返回</li><li>如果 key 值不在缓存中, 则会根据 key 进行查询数据库</li><li>读取成功后, 将数据写入缓存</li><li>返回数据</li></ol><p>写数据:</p><ol><li>根据 key 值写路数据库中</li><li>写入成功后, 将数据更新至缓存</li><li>成功返回</li></ol><h3 id="redis-数据类型" tabindex="-1"><a class="header-anchor" href="#redis-数据类型" aria-hidden="true">#</a> Redis 数据类型</h3><table><thead><tr><th>类型</th><th>举例</th></tr></thead><tbody><tr><td>string</td><td>实体的某个属性可以从其他属性或其他数据推导出来，那么这个属性就是派生属性。</td></tr><tr><td>hash</td><td>代替 string 类型，节省空间。描述用户信息较为方便</td></tr><tr><td>set</td><td>无序集合，每个值不能重复。可用于去重、抽奖、初始化用户池等</td></tr><tr><td>list</td><td>双向链表结构，可以模拟栈、队列等形式。可用于回复评论、点赞</td></tr><tr><td>zset</td><td>有序集合、每个元素有一个分数。如首页推荐 10 个最热门的帖子</td></tr><tr><td>pub/sub</td><td>可以用做消息队列，生产者将消息投送给某个 key 为主题的队列，消费者监听并得到消息的推送</td></tr></tbody></table><h3 id="redis-持久化机制" tabindex="-1"><a class="header-anchor" href="#redis-持久化机制" aria-hidden="true">#</a> Redis 持久化机制</h3><table><thead><tr><th></th><th>RDB 内存快照(RedisDataBase)</th><th>AOF 日志(Append Only Flie)</th></tr></thead><tbody><tr><td>说明</td><td>把当前内存中的数据集快照写入磁盘</td><td></td></tr></tbody></table><p>(数据库中所有键<br> 值对数据)恢复时是将快照文件直接读到内存里。 | 通过持续不断地保存 Redis 服务器所执行的更新命令来记录数据库状态，类似 mysql 的 binlog。恢复数据时需要从头开始回放更新命令。 |<br> | 磁盘刷新频率 | 低 | 高 |<br> | 文件大小 | 小 | 大 |<br> | 数据恢复效率 | 高 | 低 |<br> | 数据安全 | 低 | 高 |</p><h3 id="redis-过期策略" tabindex="-1"><a class="header-anchor" href="#redis-过期策略" aria-hidden="true">#</a> Redis 过期策略</h3><ul><li>惰性删除 <ul><li>查询 key 的时候才对 key 进行检测，如果已经达到过期时间，则删除。缺点是如果这些过期的 key 没有被访问，那么他就一直无法被删除，而且一直占用内存。</li></ul></li><li>定期删除 <ul><li>redis 每隔一段时间对数据库做一次检查，删除里面的过期 key。由于不可能对所有 key 去做轮询来删除，所以 redis 会每次随机取一些 key 去做检查和删除。</li></ul></li><li>内存淘汰机制 <ul><li>当内存不足时，redis 会根据一定的策略去删除一些 key。策略有 noeviction、allkeys-lru、volatile-lru、allkeys-random、volatile-random、volatile-ttl。</li></ul></li></ul><h3 id="redis-缓存异常" tabindex="-1"><a class="header-anchor" href="#redis-缓存异常" aria-hidden="true">#</a> Redis 缓存异常</h3><ol><li>缓存穿透: 访问的 key 在 redis 中不存在，导致请求直接访问数据库。</li></ol><table><thead><tr><th>原因</th><th>解决方案</th></tr></thead><tbody><tr><td>恶意攻击，造成大量访问 Redis 中不存在的 key</td><td>1、针对来源是比较少的请求来源 ip 主动限制访问次数，或者拉入黑名单。2、应用程序检查 key 的合法性，提前拒绝不合法的请求。3、使用布隆过滤器。</td></tr><tr><td>大量请求访问数据库里有但 redis 没有的 key。</td><td>1、预热 redis，运行一个批处理脚本，将可能会大量访问的数据预先加载到 redis，业务再开张。2、在最前端进行流量控制，逐步释放进来请求。给出一段时间，让 redis 逐步加载热数据。3、如果数据库里也没有的 key，也要在 redis 中设置 key，使其值为 null 或空。</td></tr></tbody></table><ol start="2"><li>缓存雪崩: Redis 的 key 是已存在的，但同时失效了。</li></ol><table><thead><tr><th>原因</th><th>解决方案</th></tr></thead><tbody><tr><td>redis 故障。比如 redis 宕机，网路出现抖动等。</td><td>1、使用主从复制提高可用性， 使用 cluster 集群方案降低故障时影响的范围。2、如果出现故障，则可以采取服务降级、熔断、限流等措施。</td></tr><tr><td>采用了相同的过期时间,例如在同一时刻设置了大量的 key，但过期时间都是 5 分钟。</td><td>过期时间加上一个随机值，使得众多 key 均匀过期。</td></tr></tbody></table><ol start="3"><li>缓存击穿: 少量热点的 key 缓存时间失效了。</li></ol><table><thead><tr><th>原因</th><th>解决方案</th></tr></thead><tbody><tr><td>热点的 key 设置了太短的过期时间。例如秒杀业务下的&quot;库存数量&quot;</td><td>1、设置较长的过期时间。非常重要的 key，则设置永久有效但需要解决好与数据库中的 key 的一致性问题使用分布式锁:如果热点 key 失效了，要控制好访问后端数据库的流量。2、只允许一个请求去访问数据库，取出最新的 key，存放到 redis，其他请求必须等待。但分布式锁也要防止出现异常的情况。</td></tr></tbody></table>',102),l=[r];function h(o,c){return d(),a("div",null,l)}const u=e(t,[["render",h],["__file","case-analysis-database.html.vue"]]);export{u as default};
