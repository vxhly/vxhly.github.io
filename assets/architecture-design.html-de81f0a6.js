import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as t,c as d,e as a}from"./app-95dad6bf.js";const i={},l=a('<div class="hint-container tip"><p class="hint-container-title">前言</p><p><code>系统架构设计师</code> 考试中下午案例分析题知识点汇总。本篇是架构设计专题部分。</p></div><h2 id="软件架构风格" tabindex="-1"><a class="header-anchor" href="#软件架构风格" aria-hidden="true">#</a> 软件架构风格</h2><p>架构的本质</p><ul><li>架构风格定义了用于描述系统的术语表和一组指导构建系统的规则。</li><li>软件架构为软件系统提供了一个结构、行为和属性的高级抽象。</li></ul><p>架构的作用</p><ul><li>软件架构是项目干系人进行交流的手段。</li><li>软件架构是可传递和可复用的模型，通过研究软件架构可能预测软件的质量。</li><li>、软件架构使推理和控制的更改更加简单，有助于循序渐进的原型设计，可以作为培训的基础。</li></ul><h3 id="批处理风格" tabindex="-1"><a class="header-anchor" href="#批处理风格" aria-hidden="true">#</a> 批处理风格</h3><ul><li>每个处理步骤是一个单独的程序，每一步必须在前一步结束后才能开始，并且数据必须是完整的，以整体的方式传递。它的基本构件是独立的应用程序，连接件是某种类型的媒介。</li></ul><h3 id="管道-过滤器风格" tabindex="-1"><a class="header-anchor" href="#管道-过滤器风格" aria-hidden="true">#</a> 管道-过滤器风格</h3><ul><li>把系统分解为几个处理步骤，这些步骤之间通过数据流连接，一个步骤的输出是另一个步骤的输入。每个处理步骤由一个过滤器实现，处理步骤之间的数据传输由管道负责。每个处理步骤（过滤器）都有一组输入和输出，过滤器从管道中读取输入的数据流，经过内部处理，然后产生输出数据流并写入管道中。基本构件是过滤器，连接件是数据流传输管道。</li></ul><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>1.简单性;2.支持复用;3.便于系统分析</td><td>1.不适合用来设计交互式应用系统;2.由于没有通用的数据传输标准，因此每个过滤器都需要解析输入数据和合成数据;3.难以进行错误处理。</td></tr></tbody></table><h3 id="主程序-子程序风格" tabindex="-1"><a class="header-anchor" href="#主程序-子程序风格" aria-hidden="true">#</a> 主程序／子程序风格</h3><ul><li>主程序/子程序风格一般采用单线程控制，把问题划分为若干处理步骤，构件即为主程序和子程序。子程序通常可合成为模块。过程调用作为交互机制，即充当连接件。调用关系具有层次性，其语义逻辑表现为子程序的正确性取决于它调用的子程序的正确性。</li></ul><h3 id="面向对象架构风格" tabindex="-1"><a class="header-anchor" href="#面向对象架构风格" aria-hidden="true">#</a> 面向对象架构风格</h3><ul><li>面向对象系统风格建立在数据抽象和面向对象的基础上，数据的表示方法和它们的相应操作封装在一个抽象数据类型或对象中。这种风格的构件是对象。</li></ul><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>1.一个对象对外隐藏了自己的详细信息;2.对象将数据和操作封装在一起;3.继承和封装方法为对象服用提供了技术支持</td><td>如果一个对象要调用另一个对象，则必须知道它的标识和名称</td></tr></tbody></table><h3 id="层次架构风格" tabindex="-1"><a class="header-anchor" href="#层次架构风格" aria-hidden="true">#</a> 层次架构风格</h3><ul><li>层次系统组成一个层次结构，每一层为上层提供服务，并作为下层的客户。这样的系统中构件在层上实现了虚拟机。连接件由通过层间交互协议来定义，拓扑约束包括对相邻层间交互的约束。</li><li>每一层最多只影响两层，同时只要给相邻层提供相同的接口，允许每层用不同的方法实现，为软件重用提供了强大的支持。</li></ul><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>1.设计者可以将系统分解为一个增量的步骤序列从而完成复杂的业务逻辑;2.每一层最多和相邻的上下两层进行交互，只给相邻层提供相同的接口。</td><td>1.并非所有系统都能够按照层次来进行划分。2.很难找到一种合适和正确的层次划分方法。3.传输数据需要经过多个层次。4.多层结构难以调试。</td></tr></tbody></table><h3 id="c-s-架构风格" tabindex="-1"><a class="header-anchor" href="#c-s-架构风格" aria-hidden="true">#</a> C/S 架构风格</h3><p>客户端/服务器体系结构风格是基于资源不对等，且为实现共享而提出的。两层 C/S 体系结构有 3 个主要组成部分：数据库服务器、客户应用程序和网络。三层 C/S 结构增加了一个应用服务器。整个应用逻辑驻留在应用服务器上。应用功能分为表示层、功能层和数据层三层。</p><h3 id="事件驱动的系统-隐式调用风格" tabindex="-1"><a class="header-anchor" href="#事件驱动的系统-隐式调用风格" aria-hidden="true">#</a> 事件驱动的系统/隐式调用风格</h3><ul><li>基于事件的隐式调用风格的思想是构件不直接调用一个过程，而是触发或广播一个或多个事件。系统中的其他构件中的过程在一个或多个事件中注册，当一个事件被触发，系统自动调用在这个事件中注册的所有过程。</li></ul><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>1.事件发布者不需要知道哪些构件会响应事件</td><td>1.构件放弃了对计算的控制权，完全由系统来决定;2.存在数据传输问题</td></tr></tbody></table><h3 id="基于规则的系统架构风格" tabindex="-1"><a class="header-anchor" href="#基于规则的系统架构风格" aria-hidden="true">#</a> 基于规则的系统架构风格</h3><ul><li>基于规则的系统包括规则集、规则解释器、规则/数据选择器及工作内存。</li></ul><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>1.规则数据可以动态改变，灵活性好;2.定义新的规则，即可扩展</td><td>1.实时解释规则、性能较差</td></tr></tbody></table><h3 id="仓库风格" tabindex="-1"><a class="header-anchor" href="#仓库风格" aria-hidden="true">#</a> 仓库风格</h3><ul><li>仓库是存储和维护数据的中心场所。两种不同的构件：中央数据结构说明当前数据的状态以及一组对中央数据进行操作的独立构件，仓库与独立构件间的相互作用在系统中会有大的变化。</li><li>连接件即为仓库与独立构件之间的交互。</li></ul><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>1.便于多客户共享大量数据,而不必关心数据是何时产生的、由谁提供的及通过何种途径来提供。</td><td>1.对共享数据结构，不同知识源要达成一致; 2.需要同步机制和加锁机制来保证数据的完整性和一致性，增大了系统设计的复杂度</td></tr></tbody></table><h3 id="黑板风格" tabindex="-1"><a class="header-anchor" href="#黑板风格" aria-hidden="true">#</a> 黑板风格</h3><ul><li>黑板系统是一种问题求解模型。它将问题的解空间组织成一个或多个应用相关的分级结构。分级结构的每一层信息由一个唯一的词汇来描述，它代表了问题的部分解。</li></ul><h3 id="解释器风格" tabindex="-1"><a class="header-anchor" href="#解释器风格" aria-hidden="true">#</a> 解释器风格</h3><ul><li>一个解释器包括（1）完成解释工作的解释引擎（2）一个包含将被解释的代码的存储区（3）一个记录解释引擎当前工作状态的数据结构（4）一个记录源代码被解释执行进度的数据结构。</li><li>解释器缺点是执行效率较低。</li></ul><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>1.可移植性好</td><td>1.由于使用了特定了语言和自定义操作规则，因此增加了系统运行的开销;2.解释器系统难以设计和测试。</td></tr></tbody></table><h3 id="进程通信风格" tabindex="-1"><a class="header-anchor" href="#进程通信风格" aria-hidden="true">#</a> 进程通信风格</h3><ul><li>在进程通信结构体系结构风格中，构件是独立的过程，连接件是消息传递。这种风格的特点是构件通常是命名过程，消息传递的方式可以是点到点、异步或同步方式及远程过程调用等。</li></ul><h3 id="c2-风格" tabindex="-1"><a class="header-anchor" href="#c2-风格" aria-hidden="true">#</a> C2 风格</h3><p>（1）构件和连接件都有顶部和底部。<br> （2）构件的顶部连接到连接件的底部,构件的底部连接到连接件的顶部,构件之间不允许直接连接。<br> （3）连接件可以连接任意数量的构件和其他连接件。<br> （4）当两个连接件直接相连时，必须一个的底部连接到另一个的顶部。</p><h2 id="软件架构评估" tabindex="-1"><a class="header-anchor" href="#软件架构评估" aria-hidden="true">#</a> 软件架构评估</h2><h3 id="质量属性" tabindex="-1"><a class="header-anchor" href="#质量属性" aria-hidden="true">#</a> 质量属性</h3><ul><li><code>性能</code>: 处理任务所需时间或者单位时间内的处理量 <ul><li>常用的设计策略为: <code>优先级队列</code>和<code>资源调度</code></li></ul></li><li><code>可靠性</code>: 正常运行的时间比例, 出现故障多久能启用系统 <ul><li>常用的设计策略为: <code>冗余设计</code>和<code>心跳</code></li></ul></li><li><code>安全性</code>: 系统的向合法用户提供服务并且阻止非法用户的能力 <ul><li>常用的设计策略为: <code>追踪审计</code></li></ul></li><li><code>可维护性</code>: 错误发生后进局部性修改, 对其他构件负面影响最小</li><li><code>可扩展性</code>: 使用新构件、改进或删除原有构件或特性</li><li><code>结构重组性</code>: 重新组织构件及构件关系、灵活配置构件</li><li><code>可移植性</code>: 多样的环境(硬件平台、语言、操作系统等)</li><li><code>易用性</code>: 在指定条件下使用时，软件产品被理解、学习、使用和吸引用户的能力</li></ul><h3 id="质量特性" tabindex="-1"><a class="header-anchor" href="#质量特性" aria-hidden="true">#</a> 质量特性</h3><ul><li><code>敏感点</code>: 为了实现某种特定的质量属性，一个或多个构件所具有的特性。 <ul><li>对查询请求处理时间的要求将影响系统的数据传输协议和处理过程的设计</li></ul></li><li><code>权衡点</code>: 指影响多个质量特性，并对多个质量特性来说都是敏感点的质量特性。 <ul><li>改变业务数据编码方式会对系统的性能和安全性产生影响</li></ul></li><li><code>风险</code>: 不以标准术语出现。某些做法有一些隐患可能导致一些问题。 <ul><li>对系统某业务逻辑的描述尚未达成共识，这可能导致部分业务功能模块的重复，影响系统的可修改性;</li></ul></li><li><code>非风险</code>: 某些做法是可行的、可接受的。 <ul><li>业务处理时间小于 30 毫秒，则将请求响应时间设定为 1 秒钟是可以接受的</li></ul></li></ul>',44),h=[l];function r(c,o){return t(),d("div",null,h)}const s=e(i,[["render",r],["__file","architecture-design.html.vue"]]);export{s as default};
