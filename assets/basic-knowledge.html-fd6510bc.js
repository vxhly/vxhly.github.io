import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as d,c,e as a}from"./app-b8b4b755.js";const i={},o=a('<div class="hint-container tip"><p class="hint-container-title">前言</p><p><code>系统架构设计师</code> 考试中上午选择题知识点汇总。</p></div><h2 id="名词解释" tabindex="-1"><a class="header-anchor" href="#名词解释" aria-hidden="true">#</a> 名词解释</h2><h3 id="电子政务" tabindex="-1"><a class="header-anchor" href="#电子政务" aria-hidden="true">#</a> 电子政务</h3><ul><li><code>G2B</code>: 政府对企业</li><li><code>G2C</code>: 政府对公民</li><li><code>G2E</code>: 政府对公务员</li><li><code>G2G</code>: 政府对政府</li></ul><h3 id="云计算" tabindex="-1"><a class="header-anchor" href="#云计算" aria-hidden="true">#</a> 云计算</h3><ul><li><code>PaaS</code>: 平台即服务</li><li><code>SaaS</code>: 软件（应用）即服务</li><li><code>IaaS</code>: 基础设施即服务</li></ul><h3 id="数据库设计规范" tabindex="-1"><a class="header-anchor" href="#数据库设计规范" aria-hidden="true">#</a> 数据库设计规范</h3><ul><li><code>第一范式（1NF）</code>: 若关系模型 R 的每一个属性是不可再分的数据项, 则符合 <code>1NF</code></li><li><code>第二范式（2NF）</code>: 若关系模型 <code>R ∈ 1NF</code>, 且每一个非主属性完全依赖主键, 则符合 <code>2NF</code></li><li><code>第三范式（3NF）</code>: 即当 2NF 消除了非主属性对主键的传递依赖, 则符合 <code>3NF</code></li></ul><h2 id="计算机原理" tabindex="-1"><a class="header-anchor" href="#计算机原理" aria-hidden="true">#</a> 计算机原理</h2><h3 id="指令系统" tabindex="-1"><a class="header-anchor" href="#指令系统" aria-hidden="true">#</a> 指令系统</h3><ul><li>指令系统是计算机硬件的语言系统, 是机器所具有的全部指令的集合, 反映了计算机所拥有的基本功能。</li></ul><h3 id="计算机存储" tabindex="-1"><a class="header-anchor" href="#计算机存储" aria-hidden="true">#</a> 计算机存储</h3><ul><li>存储速度从快到慢分别是：寄存器组、Cache、内存、Flash。</li></ul><h3 id="系统性能评价" tabindex="-1"><a class="header-anchor" href="#系统性能评价" aria-hidden="true">#</a> 系统性能评价</h3><ul><li>通常用户采用评价程序来评价系统的性能。评价程序一般有专门的测量程序、仿真程序等, 而评测准确度最高的评价程序是真实程序。</li></ul><h2 id="计算机网络" tabindex="-1"><a class="header-anchor" href="#计算机网络" aria-hidden="true">#</a> 计算机网络</h2><h3 id="常见的-tcp-udp-端口号" tabindex="-1"><a class="header-anchor" href="#常见的-tcp-udp-端口号" aria-hidden="true">#</a> 常见的 TCP/UDP 端口号</h3><ul><li><code>HTTP</code>: 80</li><li><code>HTTPS</code>: 443</li><li><code>FTP</code>: 21 用来传输控制信息, 20 用来传输文件内容</li><li><code>TFTP</code>: 69 (建立在 UDP 上)</li><li><code>POP3</code>: 110</li><li><code>SMTP</code>: 25</li><li><code>IMAP</code>: 143</li></ul><h2 id="数据库" tabindex="-1"><a class="header-anchor" href="#数据库" aria-hidden="true">#</a> 数据库</h2><h3 id="armstrong-公理" tabindex="-1"><a class="header-anchor" href="#armstrong-公理" aria-hidden="true">#</a> Armstrong 公理</h3><div class="hint-container tip"><p class="hint-container-title">提示</p><p>设关系模式 <code>R&lt;U,F&gt;</code>, 其中 U 为属性集合, F 是 U 上的一组函数依赖, 则有以下的推论</p></div><ul><li>自反律: 若 <code>Y⊆X⊆U</code>, 则 <code>X-&gt;Y</code> 为 F 所蕴含</li><li>增广律: 若 <code>X-&gt;Y</code> 为 F 所蕴含, 且 <code>Z⊆U</code>, 则 <code>XZ-&gt;YZ</code> 为 F 所蕴含</li><li>传递律: 若 <code>X-&gt;Y</code>, <code>Y-&gt;Z</code> 为 F 所蕴含, 则 <code>X-&gt;Z</code> 为 F 所蕴含</li><li>合并规则: 若 <code>X-&gt;Y</code>, <code>X-&gt;Z</code>, 则 <code>X-&gt;YZ</code> 为 F 所蕴含</li><li>伪传递规则: 若 <code>X-&gt;Y</code>, <code>WY-&gt;Z</code>, 则 <code>XW-&gt;Z</code> 为 F 所蕴含</li><li>分解规则: 若 <code>X-&gt;Y</code>, <code>Z⊆Y</code>, 则 <code>X-&gt;Z</code> 为 F 所蕴含</li></ul>',22),l=[o];function r(h,t){return d(),c("div",null,l)}const u=e(i,[["render",r],["__file","basic-knowledge.html.vue"]]);export{u as default};
