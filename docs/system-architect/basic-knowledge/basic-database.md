---
author: 星火燎原@vxhly
title: 系统架构-章节重点整理-数据库
category: [软考]
tag:
  - 软考
  - 系统架构设计师

date: 2024-04-12 18:15:49
---

::: tip 前言

整理 `数据库` 章节的重点

:::

## 三级模式

- `外模式`用以描述用户（包括程序员和终端用户）看到或使用的那部分数据的逻辑结构, 是数据库用户的数据视图, 是与某一应用有关的数据的逻辑表示。一个数据库可以有多个外模式, 一个应用程序只能使用一个外模式。对应的是`视图`级别。
- `概念模式`也称为模式或逻辑模式, 对应于概念级数据库。一个数据库只有一个概念模式。对应的是`表`级别。
- `内模式`对应于物理级数据库, 是数据物理结构和存储方式的描述, 是数据在数据库内部的表示方式。对应的是`文件`级别。

## 两级独立性

数据库系统两级独立性是指`物理独立性`和`逻辑独立性`。

- `物理独立性`是指用户的应用程序与存储在磁盘上的数据库中的数据是相互独立的
- `逻辑独立性`是指用户的应用程序与数据库中的逻辑结构是相互独立的, 当数据的逻辑结构改变时, 应用程序不需要改变

## 数据模型

- 数据模型所描述的内容包括三个部分, 分别是`数据结构、数据操作和数据约束`。
- 基本数据模型: `层次模型、网状模型、关系模型和面向对象模型`。

## 关系运算基础

### 并

计算两个关系在集合理论上的并集, 即给出关系 R 和 S（两者有相同元/列数） 的元组包括 R 和 S 所有元组的集合

::: tip 公式

$R \cup S \equiv \lbrace t|t \in R \vee t \in S \rbrace$

:::

### 差

计算两个关系的区别的集合, 即给出关系 R 和 S（两者有相同元/列数）, R-S 的元组包括 R 中有而 S 中没有的元组的集合

::: tip 公式

$R - S \equiv \lbrace t|t \in R \vee t \notin S \rbrace$

:::

### 交

计算两个关系集合理论上的交集, 即给出关系 R 和 S (两者有相同元/列数), R $\cap$ S 的元组包括 R 和 S 相同元组的集合

::: tip 公式

$R \cap S \equiv \lbrace t|t \in R \wedge t \in S \rbrace$

:::

### 笛卡尔积

计算两个关系的笛卡尔乘积, 令 R 为有 m 元的关系, S 为有 n 元的关系, 则 R $\Chi$ S 是 m + n 元的元组的集合, 其前 m 个元素来自 R 的一个元组, 而后 n 个元素来自 S 的一个元组

::: tip 公式

$R \Chi S \equiv \lbrace t|t = < t_r, t_s > \wedge t_r \in R \wedge t_s \in S \rbrace$

:::

### 投影

从一个关系中抽取指明的属性（列）。令及为一个包含属性 A 的关系

::: tip 公式

$\Pi_A (R) \equiv \lbrace t[A]|t \in R \rbrace$

:::

### 选择

从一个关系中抽取指明的属性（列）。令及为一个包含属性 A 的关系

::: tip 公式

$\sigma_F (R) \equiv \lbrace t|t \in R \wedge F(t) = true \rbrace$

:::

### $\theta$ 连接

$\theta$ 连接从两个关系的笛卡儿积中选取属性之间满足一定条件的元组

两个关系中进行比较的分量必须是相同的属性组, 并且在结果中将重复的属性去掉, 则称为自然连接

::: tip 公式

$R \begin{matrix} \bowtie \\ A=B\end{matrix} S \equiv \lbrace t_r, t_s|t_r \in R \wedge t_s \in S \wedge t_r[A] s= t_s[B] \rbrace$

:::

如果两个关系中进行比较的分量必须是相同的属性组, 并且在结果中将重复的属性去掉, 则称为自然连接

::: tip 公式

$R \bowtie  S \equiv \lbrace t_r, t_s|t_r \in R \wedge t_s \in S \wedge t_r[A] s= t_s[B] \rbrace$

:::

## Armstrong 公理

::: tip 前置条件

设关系模式 `R<U, F>`, 其中 U 为属性集合, F 是 U 上的一组函数依赖, 则有以下的推论

:::

- 自反律: 若 Y $\subseteq$ X $\subseteq$ U, 则 X $\rightarrow$ Y 为 F 所蕴含
- 增广律: 若 X $\rightarrow$ Y 为 F 所蕴含, 且 Z $\subseteq$ U, 则 XZ $\rightarrow$ YZ 为 F 所蕴含
- 传递律: 若 X $\rightarrow$ Y, Y $\rightarrow$ Z 为 F 所蕴含, 则 X $\rightarrow$ Z 为 F 所蕴含
- 合并规则: 若 X $\rightarrow$ Y, X $\rightarrow$ Z, 则 X $\rightarrow$ YZ 为 F 所蕴含
- 伪传递规则: 若 X $\rightarrow$ Y, WY $\rightarrow$ Z, 则 XW $\rightarrow$ Z 为 F 所蕴含
- 分解规则: 若 X $\rightarrow$ Y, Z $\subseteq$ Y, 则 X $\rightarrow$ Z 为 F 所蕴含

## 规范化

### 存储异常

- 数据冗余
- 修改异常
- 插入异常
- 删除异常

### 范式

- `第一范式（1NF）`。在关系模式中, 当且仅当所有属性只包含原子值, 即每个分量都是不可再分的数据项, 则称满足 1NF。
- `第二范式（2NF）`。当且仅当关系模式及满足 1NF, 且每个非键属性（即不属于任何候选键的属性, 也称为非主属性）完全依赖于候选键时, 则称满足 2NF。
- `第三范式（3NF`）。当且仅当关系模式 R 满足 1NF, 且 R 中没有非键属性传递依赖于候选键时, 则称满足 3NF。
- `BCNF`。如果关系模式及满足 1NF, 且及中没有属性传递依赖于候选键时, 则称满足 BCNF。
- `第四范式（4NF）`。第四范式是 BCNF 的推广, 是针对有多值依赖的关系模型所定义的规范化形式。把一个表中多个多值依赖拆分开来。

### 反规范化设计

::: tip

规范化设计后, 数据库设计者希望牺牲部分规范化来提高性能, 这种从规范化设计的回退方法称为反规范化技术。
逆规范化方法优点：提高统计、查询效率。
逆规范化方法缺点：增加了数据冗余, 浪费存储空间, 增、删、改操作的效率降低, 可能导致数据不一致, 可能产生添加、修改、删除异常

:::

#### 优点

- 避免进行表之间的连接操作, 可以提高数据操作的性能。
- 连接操作少, 检索快、统计快;需要查的表减少, 检索容易, 并易出错。

#### 缺点

- 数据的重复存储, 浪费了磁盘空间
- 会产生数据的不一致性问题(触发器数据同步、应用程序同步)
- 更新和插入代码更加难写
- 插入、更新、删除操作开销更大

#### 反规范化设计类型

| 类型       | 作用 / 描述                                                                                                          |
| ---------- | -------------------------------------------------------------------------------------------------------------------- |
| 增加冗余列 | 增加冗余列是指在多个表中具有相同的列, 它常用来在查询时避免连接操作。                                                 |
| 增加派生列 | 增加派生列指增加的列可以通过表中其他数据计算生成它的作用是在查询时减少计算量, 从而加快查询速度                       |
| 重新组表   | 重新组表指如果许多用户需要查看两个表连接出来的结果数据, 则把这两个表重新组成一个表来减少连接而提高性能               |
| 水平分割表 | 按记录进行分割, 把数据放到多个独立的表中, 主要用于表数据规模很大、表中数据相对独立或数据需要存放到多个介质上时使用。 |
| 垂直分割表 | 对表进行分割, 将主键与部分列放到一个表中, 主键与其它列放到另一个表中, 在查询时减少 1/0 次数。                        |

#### 数据一致性

反规范化设计保证数据的一致性方法:

- 触发器
- 事务机制保证
- 应用保证
- 批处理脚本

## 数据库访问接口

常见的数据库访问接口有专用调用、开放数据库互连（ODBC）和 Java 数据库连接（JDBC）等。

ODBC 缺点:

- ODBC 只支持关系型数据, 像电子邮件之类的非关系型数据是不支持的。
- 由于 ODBC 最初的设计理念就是能够访问所有类型数据库, 这种普遍适用也造成了 ODBC 对每种数据库的支持都不是特别理想。
- 使用 ODBC 需要进行一些系统的配置工作。当然, 这个操作也是可以用程序来完成的。

## 事务的特性

（1）`原子性（Atomicity）`。事务是数据库的逻辑工作单位, 事务的原子性保证事务包含的一组更新操作是原子不可分的, 也就是说, 这些操作是一个整体, 不能部分地完成。
（2）`一致性（Consistency）`。一致性是指使数据库从一个一致性状态变到另一个一致性状态。
（3）`隔离性（Isolation）`。隔离性是指一个事务的执行不能被其他事务干扰, 即一个事务内部的操作及使用的数据对并发的其他事务是隔离的, 并发执行的各个事务之间不能互相干扰。
（4）`持久性（Durability）`。持久性也称为永久性, 是指事务一旦提交, 改变就是永久性的, 无论发生何种故障, 都不应该对其有任何影响。

## 数据库的完整性

- `完整性约束条件`: 完整性检查是指对数据库中的数据设置约束条件, 确保数据符合预定义的规则。 完整性检查可以帮助我们防止数据错误。 完整性控制机制包括定义功能和检查功能。定义功能用于定义完整性约束条件。检查功能用于检查用户操作是否违反了完整性约束条件。完整性检查可以分为静态约束和动态约束。静态约束对数据库中数据本身的限制, 例如数据类型、取值范围等。动态约束对数据库中数据变化的限制。
- `实体完整性`: 实体完整性要求主键中的任一属性不能为空, 所谓空值是“不知道”或“无意义”的值。
- `参照完整性`: 若基本关系及中含有与另一基本关系 S 的主键 PK 相对应的属性组 FK（FK 称为 R 的外键）, 则参照完整性要求, 对及中的每个元组在 FK 上的值必须是 S 中某个元组的 PK 值, 或者为空值。
- `用户定义的完整性`: 用户定义的完整性就是针对某一具体数据库的约束条件, 反映某一具体应用所涉及的数据必须满足的语义要求。
- `触发器`: 所谓触发器, 其抽象的含义即是一个事件的发生必然触发（或导致）另外一些事件的发生, 其中前面的事件称为触发事件, 后面的事件称为结果事件。触发事件一般即为完整性约束条件的否定, 而结果事件即为一组操作用以消除触发事件所引起的不良影响。 触发器除了有完整性保护功能外, 还有安全性保护功能。

## 数据库性能优化

### 索引优化策略

（1）建立索引时, 应选用经常作为査询, 而不常更新的属性。避免对一个经常被更新的属性建立索引, 因为这样会严重影响性能。
（2）一个关系上的索引过多会影响 UPDATE、INSERT 和 DELETE 的性能, 因为关系一旦进行更新, 所有的索引都必须跟着做相应的调整。
（3）尽量分析出每个重要查询的使用频度, 这样, 可以找出使用最多的索引, 然后可以先对这些索引进行适当的优化。
（4）对于数据量非常小的关系不必建立索引, 因为对于小关系而言, 关系扫描往往更快, 而且消耗的系统资源更少。

### 查询优化

（1）建立物化视图或尽可能减少多表查询；
（2）以不相干子查询替代相干子查询；
（3）只检索需要的属性；
（4）用带 IN 的条件子句等价替换 OR 子句；
（5）经常提交（COMMIT）以尽早释放锁等。

## 数据库的安全性

| 措施                | 说明                                                                     |
| ------------------- | ------------------------------------------------------------------------ |
| 用户标识和鉴别      | 最外层的安全保护措施, 可以使用用户账户、口令和随机数检验等方式           |
| 存储控制 (数据授权) | 对用户进行授权, 包括操作类型 (例如, 查找、更新或删除等) 和数据对象的权限 |
| 密码存储和传输      | 对远程终端信息用密码传输                                                 |
| 视图的保护          | 通过视图的方式进行授权                                                   |
| 审计                | 使用一个专用文件或数据库, 自动将用户数据库的所有操作记录下来             |

## 数据库设计与建模

> 基于数据库系统生命周期的数据库设计可分为如下 5 个阶段：`规划、需求分析、概念设计、逻辑设计和物理设计`。

### 设计阶段

| 阶段                 | 主要任务                                                                                    |
| -------------------- | ------------------------------------------------------------------------------------------- |
| 用户需求分析         | 分析用户活动、收集数据确定系统边界。                                                        |
| 概念结构设计         | 将应用对象抽象成不依赖于 DBMS 的数据模型, 即概念模型。描述概念模型的较理想的工具是 E-R 图。 |
| 逻辑结构设计         | 将抽象的概念模型转化为与选用的 DBMS 产品所支持的数据模型相符合的逻辑模型, 即关系模式。      |
| 物理结构设计         | 是逻辑模型在计算机中的具体实现方案。                                                        |
| 数据库实施阶段       | 根据前两个阶段的结果建立数据库, 编制与调试应用程序, 组织数据入库, 并进行试运行。            |
| 数据库运行和维护阶段 | 数据库应用系统经过试运行即可投入运行, 但该阶段需要不断地对系统进行评价、调整与修改。        |

### 规划

规划阶段的主要任务是进行`建立数据库的必要性及可行性分析`, 确定数据库系统在企业和信息系统中的地位, 以及各个数据库之间的联系。

### 需求分析

调查组织机构情况、调查各部门的业务活动情况、协助用户明确对新系统的各种要求、确定新系统的边界, 以此获得用户对系统的如下要求。
① `信息要求`: 保存的信息、完整性要求等。
② `处理要求`: 操作功能、处理的频度、相应时间等。
③ `系统要求`: 安全性要求、使用方式要求、可扩充性要求。

### 概念结构设计

对现实事物抽象认识的 3 种方法:

1. `分类(Classification)`: 对现实世界的事物, 按照其具有的共同特征和行为, 定义一种类型。在某一类型中, 个体是类型的一个成员或实例, 即 “is member of”。
2. `聚集(Aggregation)`: 定义某一类型所具有的属性。如学生类型具有学号、姓名、性别、班级等共同属性, 每一个学生都是这一类型中的个体, 通过在这些属性上的不同取值来区分。各个属性是所属类型的一个成份, 即 “is part of”。
3. `概括(Generalization)`: 由一种已知类型定义新的类型。通常把已知类型称为超类(Superclass), 新定义的类型称为子类(Subclass), 即 “is subset"

概念设计步骤

1. 需求分析
2. 确定局部视图范围
3. 识别实体及其标识
4. 确定实体之间的联系
5. 分配实体及联系的属性
6. 全局 E-R 模式设计

冲突的类型

1. `属性冲突`: 包括属性域和属性取值的冲突
2. `结构冲突`: 包括同一个对象在不同应用中的抽象以及同一实体在不同的局部 E-R 图中所包含的属性个数和属性排列次序不完全相同
3. `命名冲突`: 包括同名异议和异名同议

### 逻辑结构设计

- 将抽象的概念模型转化为与选用的 DBMS 产品所支持的数据模型相符合的逻辑模型, 即关系模式。
- 主要工作步骤包括确定数据模型、将 E-R 图转换成为指定的数据模型、确定完整性约束和确定用户视图。

### 物理设计

物理设计的主要工作步骤包括确定数据分布、存储结构和访问方式。

### 数据库实施

数据库实施。在计算机上建立起实际的数据库结构, 数据加载(或称装入), 进行试运行和评价的过程, 叫作数据库的实施(或称实现)

### 数据库运行维护

数据库运行维护。数据库一旦投入运行, 就标志着数据库维护工作的开始。数据库维护工作的主要内容包括对数据库性能的监测和改善、故障恢复、数据库的重组和重构。
